{"version":3,"sources":["/home/ilia/code/StateMachine/StateMachine.ts","StateMachine.js"],"names":["State","StateMachine"],"mappings":"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","file":"StateMachine.js","sourcesContent":["\nvar StateMachine = (function () {\n\n  var reserved = [\"state\", \"go\", \"initialize\", \"current\"];\n\n  var isDefined   = function (x) { return typeof x !== \"undefined\"; },\n      isUndefined = function (x) { return !isDefined(x); };\n\n  /**\n   * a single state\n   *\n   * @class State\n   * @param {StateMachine} sm - state machine\n   * @param {string} name - state name\n   */\n  var State = function State(sm, name) {\n    this._sm     = sm;\n    this._name   = name;\n    this._events = {};\n    this._enter  = [];\n    this._exit   = [];\n  };\n\n  /**\n   * create a function for invoking an event\n   *\n   * @method _makeEventMethodfn\n   * @private\n   * @param {string} event - event name\n   * @return {function}\n   */\n  State.prototype._makeEventMethodFn = function (event) {\n    var sm      = this._sm,\n        verbose = sm._options.verbose,\n        name    = sm._options.name,\n        logEx   = sm._options.logExceptions;\n    return function () {\n      var state = sm._current,\n          args  = arguments,\n          events;\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      events = state._events;\n      if (isUndefined(events[event])) {\n        throw new Error(\n          event + \" event not defined for \" + state._name + \" state\"\n        );\n      }\n      if (verbose) {\n        console.log(name + \": \" + state._name + \".\" + event);\n      }\n      if (logEx) {\n        try {\n          events[event].forEach(function (fn) {\n            fn.apply(sm, args);\n          });\n        } catch (e) {\n          console.log(name + \": \" + state._name + \" ! \" + e.message);\n          throw e;\n        }\n      } else {\n        events[event].forEach(function (fn) {\n          fn.apply(sm, args);\n        });\n      }\n      return sm;\n    };\n  };\n\n  /**\n   * convert an event handler parameter to a function\n   *\n   * @method _makeEventHandlerFn\n   * @private\n   * @param {function|string|undefined} x - handler\n   * @return {function}\n   */\n  State.prototype._makeEventHandlerFn = function (x) {\n    var sm       = this._sm,\n        toString = Object.prototype.toString;\n    if (toString.call(x) === '[object Function]') {\n      return x;\n    }\n    if (typeof x === \"string\") {\n      return () => sm.go(x);\n    }\n    if (typeof x === \"undefined\") {\n      return () => undefined;\n    }\n    throw new Error(\"invalid event handler\");\n  };\n\n  /**\n   * register a state event and add the event method\n   * to the state machine instance\n   *\n   * Note:\n   *\n   *  `enter` and `exit` are special events.\n   *  event methods do not get defined for them.\n   *  they are executed when the state machine is\n   *  entering or exiting that state.\n   *\n   * @method on\n   * @param {string} event - event name\n   * @param {function|string} handler - event callback function or state name\n   * @return {State} state \n   */\n  State.prototype.on = function (event, handler) {\n    var events = this._events,\n        sm     = this._sm,\n        fn     = this._makeEventHandlerFn(handler);\n    switch (event) {\n      case \"enter\":\n        this._enter.push(fn);\n        break;\n      case \"exit\":\n        this._exit.push(fn);\n        break;\n      default:\n        if (reserved.indexOf(event) !== -1) {\n          throw new Error(event + \" method is reserved for the api\");\n        };\n        if (isUndefined(events[event])) {\n          events[event] = [];\n        }\n        events[event].push(fn);\n        if (isUndefined(sm[event])) {\n          sm[event] = this._makeEventMethodFn(event);\n        }\n        break;\n    }\n    return this;\n  };\n\n  /**\n   * See StateMachine#initialize method\n   *\n   * @method initialize\n   * @param {string} name - initial state name\n   * @return {StateMachine} state machine\n   */\n  State.prototype.initialize = function (name) {\n    return this._sm.initialize(name);\n  };\n\n  /**\n   * See StateMachine#state method\n   *\n   * @method state\n   * @param {string} name - state name\n   * @return {State} state specified by name parameter\n   */\n  State.prototype.state = function (name) {\n    return this._sm.state(name);\n  };\n\n  /**\n   * Simple State Machine\n   *\n   * @class StateMachine\n   * @param {object}  options\n   * @param {boolean} options.verbose\n   * @param {string}  options.name\n   */\n  var StateMachine = function StateMachine(options) {\n    this._states  = {};\n    this._current = null;\n\n    if (isUndefined(options)) {\n      options = {};\n    }\n    if (isUndefined(options.verbose)) {\n      options.verbose = false;\n    }\n    if (isUndefined(options.name)) {\n      options.name = \"StateMachine\";\n    }\n    if (isUndefined(options.logExceptions)) {\n      options.logExceptions = false;\n    }\n    this._options = options;\n  };\n\n  /**\n   * Initializes the state machine to an initial state.\n   * trying to invoke event methods before initializing\n   * will result in an `Error` being thrown\n   *\n   * @method initialize\n   * @param {string} name - initial state name\n   * @return {StateMachine} state machine\n   */\n  StateMachine.prototype.initialize = function (name) {\n    var states = this._states;\n    if (isUndefined(states[name])) {\n      throw new Error(name + \" state is not defined\");\n    }\n    this._current = states[name];\n    return this;\n  };\n\n  /**\n   * Creates or gets existing State\n   *\n   * @method state\n   * @param {string} name - state name\n   * @return {State} state specified by name\n   */\n  StateMachine.prototype.state = function (name) {\n    var states = this._states;\n    if (isUndefined(states[name])) {\n      states[name] = new State(this, name);\n    }\n    return states[name];\n  };\n\n  /**\n   * Gets the name of the current State\n   *\n   * @method current\n   * @return {string} name - current state name\n   */\n  StateMachine.prototype.current = function () {\n    var current = this._current;\n    if (current === null) {\n      throw new Error(\n          \"the state machine has not been initialized\");\n    }\n    return current._name;\n  };\n\n  /**\n   * Go to another state\n   *\n   * @method go\n   * @param {string} name - state to transition to\n   * @return {StateMachine} state machine\n   */\n  StateMachine.prototype.go = function (name) {\n    var state   = this._states[name],\n        current = this._current,\n        execute = fn => fn.call(this);\n    if (isUndefined(state)) {\n      throw new Error(name + \" state does not exist\");\n    }\n    if (current._name !== name) {\n      if (this._options.verbose) {\n        console.log(this._options.name + \": \" + current._name + \" -> \" + name);\n      }\n      current._exit.forEach(execute);\n      this._current = state;\n      state._enter.forEach(execute);\n    }\n    return this;\n  };\n\n  return StateMachine;\n\n}).call(this);\n","var StateMachine = (function () {\n    var reserved = [\"state\", \"go\", \"initialize\", \"current\"];\n    var isDefined = function (x) {\n        return typeof x !== \"undefined\";\n    }, isUndefined = function (x) {\n        return !isDefined(x);\n    };\n    /**\n     * a single state\n     *\n     * @class State\n     * @param {StateMachine} sm - state machine\n     * @param {string} name - state name\n     */\n    var State = function State(sm, name) {\n        this._sm = sm;\n        this._name = name;\n        this._events = {};\n        this._enter = [];\n        this._exit = [];\n    };\n    /**\n     * create a function for invoking an event\n     *\n     * @method _makeEventMethodfn\n     * @private\n     * @param {string} event - event name\n     * @return {function}\n     */\n    State.prototype._makeEventMethodFn = function (event) {\n        var sm = this._sm, verbose = sm._options.verbose, name = sm._options.name, logEx = sm._options.logExceptions;\n        return function () {\n            var state = sm._current, args = arguments, events;\n            if (state === null) {\n                throw new Error(\"the state machine has not been initialized\");\n            }\n            events = state._events;\n            if (isUndefined(events[event])) {\n                throw new Error(event + \" event not defined for \" + state._name + \" state\");\n            }\n            if (verbose) {\n                console.log(name + \": \" + state._name + \".\" + event);\n            }\n            if (logEx) {\n                try {\n                    events[event].forEach(function (fn) {\n                        fn.apply(sm, args);\n                    });\n                }\n                catch (e) {\n                    console.log(name + \": \" + state._name + \" ! \" + e.message);\n                    throw e;\n                }\n            }\n            else {\n                events[event].forEach(function (fn) {\n                    fn.apply(sm, args);\n                });\n            }\n            return sm;\n        };\n    };\n    /**\n     * convert an event handler parameter to a function\n     *\n     * @method _makeEventHandlerFn\n     * @private\n     * @param {function|string|undefined} x - handler\n     * @return {function}\n     */\n    State.prototype._makeEventHandlerFn = function (x) {\n        var sm = this._sm, toString = Object.prototype.toString;\n        if (toString.call(x) === '[object Function]') {\n            return x;\n        }\n        if (typeof x === \"string\") {\n            return function () { return sm.go(x); };\n        }\n        if (typeof x === \"undefined\") {\n            return function () { return undefined; };\n        }\n        throw new Error(\"invalid event handler\");\n    };\n    /**\n     * register a state event and add the event method\n     * to the state machine instance\n     *\n     * Note:\n     *\n     *  `enter` and `exit` are special events.\n     *  event methods do not get defined for them.\n     *  they are executed when the state machine is\n     *  entering or exiting that state.\n     *\n     * @method on\n     * @param {string} event - event name\n     * @param {function|string} handler - event callback function or state name\n     * @return {State} state\n     */\n    State.prototype.on = function (event, handler) {\n        var events = this._events, sm = this._sm, fn = this._makeEventHandlerFn(handler);\n        switch (event) {\n            case \"enter\":\n                this._enter.push(fn);\n                break;\n            case \"exit\":\n                this._exit.push(fn);\n                break;\n            default:\n                if (reserved.indexOf(event) !== -1) {\n                    throw new Error(event + \" method is reserved for the api\");\n                }\n                ;\n                if (isUndefined(events[event])) {\n                    events[event] = [];\n                }\n                events[event].push(fn);\n                if (isUndefined(sm[event])) {\n                    sm[event] = this._makeEventMethodFn(event);\n                }\n                break;\n        }\n        return this;\n    };\n    /**\n     * See StateMachine#initialize method\n     *\n     * @method initialize\n     * @param {string} name - initial state name\n     * @return {StateMachine} state machine\n     */\n    State.prototype.initialize = function (name) {\n        return this._sm.initialize(name);\n    };\n    /**\n     * See StateMachine#state method\n     *\n     * @method state\n     * @param {string} name - state name\n     * @return {State} state specified by name parameter\n     */\n    State.prototype.state = function (name) {\n        return this._sm.state(name);\n    };\n    /**\n     * Simple State Machine\n     *\n     * @class StateMachine\n     * @param {object}  options\n     * @param {boolean} options.verbose\n     * @param {string}  options.name\n     */\n    var StateMachine = function StateMachine(options) {\n        this._states = {};\n        this._current = null;\n        if (isUndefined(options)) {\n            options = {};\n        }\n        if (isUndefined(options.verbose)) {\n            options.verbose = false;\n        }\n        if (isUndefined(options.name)) {\n            options.name = \"StateMachine\";\n        }\n        if (isUndefined(options.logExceptions)) {\n            options.logExceptions = false;\n        }\n        this._options = options;\n    };\n    /**\n     * Initializes the state machine to an initial state.\n     * trying to invoke event methods before initializing\n     * will result in an `Error` being thrown\n     *\n     * @method initialize\n     * @param {string} name - initial state name\n     * @return {StateMachine} state machine\n     */\n    StateMachine.prototype.initialize = function (name) {\n        var states = this._states;\n        if (isUndefined(states[name])) {\n            throw new Error(name + \" state is not defined\");\n        }\n        this._current = states[name];\n        return this;\n    };\n    /**\n     * Creates or gets existing State\n     *\n     * @method state\n     * @param {string} name - state name\n     * @return {State} state specified by name\n     */\n    StateMachine.prototype.state = function (name) {\n        var states = this._states;\n        if (isUndefined(states[name])) {\n            states[name] = new State(this, name);\n        }\n        return states[name];\n    };\n    /**\n     * Gets the name of the current State\n     *\n     * @method current\n     * @return {string} name - current state name\n     */\n    StateMachine.prototype.current = function () {\n        var current = this._current;\n        if (current === null) {\n            throw new Error(\"the state machine has not been initialized\");\n        }\n        return current._name;\n    };\n    /**\n     * Go to another state\n     *\n     * @method go\n     * @param {string} name - state to transition to\n     * @return {StateMachine} state machine\n     */\n    StateMachine.prototype.go = function (name) {\n        var _this = this;\n        var state = this._states[name], current = this._current, execute = function (fn) { return fn.call(_this); };\n        if (isUndefined(state)) {\n            throw new Error(name + \" state does not exist\");\n        }\n        if (current._name !== name) {\n            if (this._options.verbose) {\n                console.log(this._options.name + \": \" + current._name + \" -> \" + name);\n            }\n            current._exit.forEach(execute);\n            this._current = state;\n            state._enter.forEach(execute);\n        }\n        return this;\n    };\n    return StateMachine;\n}).call(this);\n"],"sourceRoot":"/source/"}