{"version":3,"sources":["StateMachine.js","/home/ilia/code/StateMachine/StateMachine.ts"],"names":["StateMachine","_StateMachine","StateMachine.isUndefined","StateMachine.State","StateMachine.State.constructor","StateMachine.State._makeEventHandler","StateMachine.State.on","StateMachine.State.emit","StateMachine.StateMachine","StateMachine.StateMachine.constructor","StateMachine.StateMachine.init","StateMachine.StateMachine.state","StateMachine.StateMachine.emit","StateMachine.StateMachine.go"],"mappings":"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","file":"StateMachine.js","sourcesContent":["var StateMachine;\n(function (_StateMachine) {\n    function isUndefined(x) {\n        return typeof x === \"undefined\";\n    }\n    var State = (function () {\n        /**\n         * A single state\n         *\n         * @param sm - state machine\n         * @param name - state name\n         */\n        function State(sm, name) {\n            this._sm = sm;\n            this.name = name;\n            this._events = {};\n            this._enter = [];\n            this._exit = [];\n        }\n        /**\n         * Convert an event handler parameter to a function\n         *\n         * @param x Handler parameter\n         * @return Event handler\n         */\n        State.prototype._makeEventHandler = function (x) {\n            var _this = this;\n            if (typeof x === \"function\") {\n                return x;\n            }\n            if (typeof x === \"string\") {\n                return function () { return _this._sm.go(x); };\n            }\n            if (typeof x === \"undefined\") {\n                return function () { return undefined; };\n            }\n            throw new Error(\"invalid event handler\");\n        };\n        /**\n         * Register a state event and add the event method\n         * to the state machine instance\n         *\n         * Note:\n         *\n         *  `enter` and `exit` are special events.\n         *  event methods do not get defined for them.\n         *  they are executed when the state machine is\n         *  entering or exiting that state.\n         *\n         * @param event Event name\n         * @param handler Event callback function or state name\n         * @return State\n         */\n        State.prototype.on = function (event, handler) {\n            var events = this._events, sm = this._sm, fn = this._makeEventHandler(handler);\n            switch (event) {\n                case \"enter\":\n                    this._enter.push(fn);\n                    break;\n                case \"exit\":\n                    this._exit.push(fn);\n                    break;\n                default:\n                    if (!events.hasOwnProperty(event)) {\n                        events[event] = [];\n                    }\n                    events[event].push(fn);\n            }\n            return this;\n        };\n        /**\n         * Emit an event\n         *\n         * @param event Event name\n         * @param args Arguments to pass to event handler\n         */\n        State.prototype.emit = function (event) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var sm = this._sm, verbose = sm.options.verbose, name = sm.options.name, logEx = sm.options.logExceptions, state = this, events;\n            if (state === null) {\n                throw new Error(\"the state machine has not been initialized\");\n            }\n            events = state._events;\n            if (!events.hasOwnProperty(event)) {\n                throw new Error(event + \" event not defined for \" + state.name + \" state\");\n            }\n            if (verbose) {\n                console.log(name + \": \" + state.name + \".\" + event);\n            }\n            if (logEx) {\n                try {\n                    events[event].forEach(function (fn) { return fn.apply(sm, args); });\n                }\n                catch (e) {\n                    console.log(name + \": \" + state.name + \" ! \" + e.message);\n                    throw e;\n                }\n            }\n            else {\n                events[event].forEach(function (fn) { return fn.apply(sm, args); });\n            }\n        };\n        return State;\n    })();\n    _StateMachine.State = State;\n    var StateMachine = (function () {\n        /**\n         * @param options Options\n         */\n        function StateMachine(options) {\n            this._states = {};\n            this.current = null;\n            if (isUndefined(options)) {\n                options = {};\n            }\n            if (isUndefined(options.verbose)) {\n                options.verbose = false;\n            }\n            if (isUndefined(options.name)) {\n                options.name = \"StateMachine\";\n            }\n            if (isUndefined(options.logExceptions)) {\n                options.logExceptions = false;\n            }\n            this.options = options;\n        }\n        /**\n         * Initializes the state machine to an initial state.\n         * trying to invoke event methods before initializing\n         * will result in an `Error` being thrown\n         *\n         * @param name Initial state name\n         * @return State machine\n         */\n        StateMachine.prototype.init = function (name) {\n            var states = this._states;\n            if (isUndefined(states[name])) {\n                throw new Error(name + \" state is not defined\");\n            }\n            this.current = states[name];\n        };\n        /**\n         * Creates or gets existing State\n         *\n         * @param Name - state name\n         * @return State specified by name\n         */\n        StateMachine.prototype.state = function (name) {\n            var states = this._states;\n            if (!states.hasOwnProperty(name)) {\n                states[name] = new State(this, name);\n            }\n            return states[name];\n        };\n        /**\n         * Emit an event\n         *\n         * @param event Event name\n         * @param args Arguments to pass to event handler\n         */\n        StateMachine.prototype.emit = function (event) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var state = this.current;\n            if (state === null) {\n                throw new Error(\"the state machine has not been initialized\");\n            }\n            state.emit.apply(state, arguments);\n        };\n        /**\n         * Go to another state\n         *\n         * @param name State to transition to\n         */\n        StateMachine.prototype.go = function (name) {\n            var _this = this;\n            var state = this._states[name], current = this.current, execute = function (fn) { return fn.call(_this); };\n            if (isUndefined(state)) {\n                throw new Error(name + \" state does not exist\");\n            }\n            if (current.name !== name) {\n                if (this.options.verbose) {\n                    console.log(this.options.name + \": \" + current.name + \" -> \" + name);\n                }\n                current._exit.forEach(execute);\n                this.current = state;\n                state._enter.forEach(execute);\n            }\n        };\n        return StateMachine;\n    })();\n    _StateMachine.StateMachine = StateMachine;\n})(StateMachine || (StateMachine = {}));\n","module StateMachine {\n\n  function isUndefined(x) {\n    return typeof x === \"undefined\";\n  }\n\n  export interface EventHandler {\n    (...any): any;\n  }\n\n  export class State {\n\n    name:   string;\n    _enter: Array<EventHandler>;\n    _exit:  Array<EventHandler>;\n\n    private _sm:     StateMachine;\n    private _events: any;\n\n    /**\n     * A single state\n     *\n     * @param sm - state machine\n     * @param name - state name\n     */\n    constructor(sm: StateMachine, name: string) {\n      this._sm     = sm;\n      this.name    = name;\n      this._events = {};\n      this._enter  = [];\n      this._exit   = [];\n    }\n\n    /**\n     * Convert an event handler parameter to a function\n     *\n     * @param x Handler parameter\n     * @return Event handler\n     */\n    private _makeEventHandler(x?: EventHandler|string): EventHandler {\n      if (typeof x === \"function\") {\n        return x;\n      }\n      if (typeof x === \"string\") {\n        return () => this._sm.go(x);\n      }\n      if (typeof x === \"undefined\") {\n        return () => undefined;\n      }\n      throw new Error(\"invalid event handler\");\n    }\n\n    /**\n     * Register a state event and add the event method\n     * to the state machine instance\n     *\n     * Note:\n     *\n     *  `enter` and `exit` are special events.\n     *  event methods do not get defined for them.\n     *  they are executed when the state machine is\n     *  entering or exiting that state.\n     *\n     * @param event Event name\n     * @param handler Event callback function or state name\n     * @return State \n     */\n    on(event: string, handler: EventHandler|string): State {\n      var events = this._events,\n          sm     = this._sm,\n          fn     = this._makeEventHandler(handler);\n      switch (event) {\n        case \"enter\":\n          this._enter.push(fn);\n          break;\n        case \"exit\":\n          this._exit.push(fn);\n          break;\n        default:\n          if (!events.hasOwnProperty(event)) {\n            events[event] = [];\n          }\n          events[event].push(fn);\n      }\n      return this;\n    }\n\n    /**\n     * Emit an event\n     *\n     * @param event Event name\n     * @param args Arguments to pass to event handler\n     */\n    emit(event: string, ...args: Array<any>): void {\n      var sm      = this._sm,\n          verbose = sm.options.verbose,\n          name    = sm.options.name,\n          logEx   = sm.options.logExceptions,\n          state   = this,\n          events;\n\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      events = state._events;\n      if (!events.hasOwnProperty(event)) {\n        throw new Error(\n          event + \" event not defined for \" + state.name + \" state\"\n        );\n      }\n      if (verbose) {\n        console.log(name + \": \" + state.name + \".\" + event);\n      }\n      if (logEx) {\n        try {\n          events[event].forEach(\n              (fn) => fn.apply(sm, args))\n        } catch (e) {\n          console.log(name + \": \" + state.name + \" ! \" + e.message);\n          throw e;\n        }\n      } else {\n        events[event].forEach(\n            (fn) => fn.apply(sm, args));\n      }\n    }\n\n  }\n\n  export interface Options {\n    name?:          string;\n    verbose?:       boolean;\n    logExceptions?: boolean;\n  }\n\n  export interface EventMethod {\n    (...any): any;\n  }\n\n  export class StateMachine {\n\n    private _states:  { [name: string]: State };\n\n    current: State;\n    options: Options;\n\n    /**\n     * @param options Options\n     */\n    constructor(options?: Options) {\n      this._states  = {};\n      this.current = null;\n\n      if (isUndefined(options)) {\n        options = {};\n      }\n      if (isUndefined(options.verbose)) {\n        options.verbose = false;\n      }\n      if (isUndefined(options.name)) {\n        options.name = \"StateMachine\";\n      }\n      if (isUndefined(options.logExceptions)) {\n        options.logExceptions = false;\n      }\n      this.options = options;\n    }\n\n    /**\n     * Initializes the state machine to an initial state.\n     * trying to invoke event methods before initializing\n     * will result in an `Error` being thrown\n     *\n     * @param name Initial state name\n     * @return State machine\n     */\n    init(name: string) {\n      var states = this._states;\n      if (isUndefined(states[name])) {\n        throw new Error(name + \" state is not defined\");\n      }\n      this.current = states[name];\n    }\n\n    /**\n     * Creates or gets existing State\n     *\n     * @param Name - state name\n     * @return State specified by name\n     */\n    state(name: string): State {\n      var states = this._states;\n      if (!states.hasOwnProperty(name)) {\n        states[name] = new State(this, name);\n      }\n      return states[name];\n    }\n\n    /**\n     * Emit an event\n     *\n     * @param event Event name\n     * @param args Arguments to pass to event handler\n     */\n    emit(event: string, ...args: Array<any>): void {\n      var state = this.current;\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      state.emit.apply(state, arguments);\n    }\n\n    /**\n     * Go to another state\n     *\n     * @param name State to transition to\n     */\n    go(name: string): void {\n      var state   = this._states[name],\n          current = this.current,\n          execute = fn => fn.call(this);\n      if (isUndefined(state)) {\n        throw new Error(name + \" state does not exist\");\n      }\n      if (current.name !== name) {\n        if (this.options.verbose) {\n          console.log(this.options.name + \": \" + current.name + \" -> \" + name);\n        }\n        current._exit.forEach(execute);\n        this.current = state;\n        state._enter.forEach(execute);\n      }\n    }\n  }\n\n}\n"],"sourceRoot":"/source/"}