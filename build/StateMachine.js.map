{"version":3,"sources":["/home/ilia/code/StateMachine/StateMachine.ts","StateMachine.js"],"names":["StateMachine","StateMachine.isUndefined","StateMachine.State","StateMachine.State.constructor","StateMachine.State._makeEventHandler","StateMachine.State.on","StateMachine.StateMachine","StateMachine.StateMachine.constructor","StateMachine.StateMachine.initialize","StateMachine.StateMachine.state","StateMachine.StateMachine.current","StateMachine.StateMachine.emit","StateMachine.StateMachine.go"],"mappings":"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","file":"StateMachine.js","sourcesContent":["module StateMachine {\n\n  function isUndefined(x) {\n    return typeof x === \"undefined\";\n  }\n\n  export interface EventHandler {\n    (...any): any;\n  }\n\n  export class State {\n\n    _sm:     StateMachine;\n    _name:   string;\n    _events: any;\n    _enter:  Array<EventHandler>;\n    _exit:   Array<EventHandler>;\n\n    /**\n     * a single state\n     *\n     * @class State\n     * @param sm - state machine\n     * @param name - state name\n     */\n    constructor(sm: StateMachine, name: string) {\n      this._sm     = sm;\n      this._name   = name;\n      this._events = {};\n      this._enter  = [];\n      this._exit   = [];\n    }\n\n    /**\n     * Convert an event handler parameter to a function\n     *\n     * @param x Handler parameter\n     * @return Event handler\n     */\n    private _makeEventHandler(x?: EventHandler|string): EventHandler {\n      if (typeof x === \"function\") {\n        return x;\n      }\n      if (typeof x === \"string\") {\n        return () => this._sm.go(x);\n      }\n      if (typeof x === \"undefined\") {\n        return () => undefined;\n      }\n      throw new Error(\"invalid event handler\");\n    }\n\n    /**\n     * Register a state event and add the event method\n     * to the state machine instance\n     *\n     * Note:\n     *\n     *  `enter` and `exit` are special events.\n     *  event methods do not get defined for them.\n     *  they are executed when the state machine is\n     *  entering or exiting that state.\n     *\n     * @param event Event name\n     * @param handler Event callback function or state name\n     * @return State \n     */\n    on(event: string, handler: EventHandler|string): State {\n      var events = this._events,\n          sm     = this._sm,\n          fn     = this._makeEventHandler(handler);\n      switch (event) {\n        case \"enter\":\n          this._enter.push(fn);\n          break;\n        case \"exit\":\n          this._exit.push(fn);\n          break;\n        default:\n          if (!events.hasOwnProperty(event)) {\n            events[event] = [];\n          }\n          events[event].push(fn);\n      }\n      return this;\n    }\n\n  }\n\n  export interface Options {\n    name?:          string;\n    verbose?:       boolean;\n    logExceptions?: boolean;\n  }\n\n  export interface EventMethod {\n    (...any): any;\n  }\n\n  export class StateMachine {\n\n    _states:  { [name: string]: State };\n    _current: State;\n    _options: Options;\n\n    /**\n     * @param options Options\n     */\n    constructor(options: Options) {\n      this._states  = {};\n      this._current = null;\n\n      if (isUndefined(options)) {\n        options = {};\n      }\n      if (isUndefined(options.verbose)) {\n        options.verbose = false;\n      }\n      if (isUndefined(options.name)) {\n        options.name = \"StateMachine\";\n      }\n      if (isUndefined(options.logExceptions)) {\n        options.logExceptions = false;\n      }\n      this._options = options;\n    }\n\n    /**\n     * Initializes the state machine to an initial state.\n     * trying to invoke event methods before initializing\n     * will result in an `Error` being thrown\n     *\n     * @param name Initial state name\n     * @return State machine\n     */\n    initialize(name: string) {\n      var states = this._states;\n      if (isUndefined(states[name])) {\n        throw new Error(name + \" state is not defined\");\n      }\n      this._current = states[name];\n    }\n\n    /**\n     * Creates or gets existing State\n     *\n     * @param Name - state name\n     * @return State specified by name\n     */\n    state(name: string): State {\n      var states = this._states;\n      if (!states.hasOwnProperty(name)) {\n        states[name] = new State(this, name);\n      }\n      return states[name];\n    }\n\n    /**\n     * Gets the name of the current State\n     *\n     * @return name Current state name\n     */\n    current(): string {\n      var current = this._current;\n      if (current === null) {\n        throw new Error(\n            \"the state machine has not been initialized\");\n      }\n      return current._name;\n    }\n\n    /**\n     * Emit an event\n     *\n     * @param event Event name\n     * @param args Arguments to pass to event handler\n     */\n    emit(event: string, ...args: Array<any>): void {\n\n      var verbose = this._options.verbose,\n          name    = this._options.name,\n          logEx   = this._options.logExceptions,\n          state   = this._current,\n          events;\n\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      events = state._events;\n      if (!events.hasOwnProperty(event)) {\n        throw new Error(\n          event + \" event not defined for \" + state._name + \" state\"\n        );\n      }\n      if (verbose) {\n        console.log(name + \": \" + state._name + \".\" + event);\n      }\n      if (logEx) {\n        try {\n          events[event].forEach(\n              (fn) => fn.apply(this, args))\n        } catch (e) {\n          console.log(name + \": \" + state._name + \" ! \" + e.message);\n          throw e;\n        }\n      } else {\n        events[event].forEach(\n            (fn) => fn.apply(this, args));\n      }\n    }\n\n    /**\n     * Go to another state\n     *\n     * @param name State to transition to\n     */\n    go(name: string): void {\n      var state   = this._states[name],\n          current = this._current,\n          execute = fn => fn.call(this);\n      if (isUndefined(state)) {\n        throw new Error(name + \" state does not exist\");\n      }\n      if (current._name !== name) {\n        if (this._options.verbose) {\n          console.log(this._options.name + \": \" + current._name + \" -> \" + name);\n        }\n        current._exit.forEach(execute);\n        this._current = state;\n        state._enter.forEach(execute);\n      }\n    }\n  }\n\n}\n","var StateMachine;\n(function (_StateMachine) {\n    function isUndefined(x) {\n        return typeof x === \"undefined\";\n    }\n    var State = (function () {\n        /**\n         * a single state\n         *\n         * @class State\n         * @param sm - state machine\n         * @param name - state name\n         */\n        function State(sm, name) {\n            this._sm = sm;\n            this._name = name;\n            this._events = {};\n            this._enter = [];\n            this._exit = [];\n        }\n        /**\n         * Convert an event handler parameter to a function\n         *\n         * @param x Handler parameter\n         * @return Event handler\n         */\n        State.prototype._makeEventHandler = function (x) {\n            var _this = this;\n            if (typeof x === \"function\") {\n                return x;\n            }\n            if (typeof x === \"string\") {\n                return function () { return _this._sm.go(x); };\n            }\n            if (typeof x === \"undefined\") {\n                return function () { return undefined; };\n            }\n            throw new Error(\"invalid event handler\");\n        };\n        /**\n         * Register a state event and add the event method\n         * to the state machine instance\n         *\n         * Note:\n         *\n         *  `enter` and `exit` are special events.\n         *  event methods do not get defined for them.\n         *  they are executed when the state machine is\n         *  entering or exiting that state.\n         *\n         * @param event Event name\n         * @param handler Event callback function or state name\n         * @return State\n         */\n        State.prototype.on = function (event, handler) {\n            var events = this._events, sm = this._sm, fn = this._makeEventHandler(handler);\n            switch (event) {\n                case \"enter\":\n                    this._enter.push(fn);\n                    break;\n                case \"exit\":\n                    this._exit.push(fn);\n                    break;\n                default:\n                    if (!events.hasOwnProperty(event)) {\n                        events[event] = [];\n                    }\n                    events[event].push(fn);\n            }\n            return this;\n        };\n        return State;\n    })();\n    _StateMachine.State = State;\n    var StateMachine = (function () {\n        /**\n         * @param options Options\n         */\n        function StateMachine(options) {\n            this._states = {};\n            this._current = null;\n            if (isUndefined(options)) {\n                options = {};\n            }\n            if (isUndefined(options.verbose)) {\n                options.verbose = false;\n            }\n            if (isUndefined(options.name)) {\n                options.name = \"StateMachine\";\n            }\n            if (isUndefined(options.logExceptions)) {\n                options.logExceptions = false;\n            }\n            this._options = options;\n        }\n        /**\n         * Initializes the state machine to an initial state.\n         * trying to invoke event methods before initializing\n         * will result in an `Error` being thrown\n         *\n         * @param name Initial state name\n         * @return State machine\n         */\n        StateMachine.prototype.initialize = function (name) {\n            var states = this._states;\n            if (isUndefined(states[name])) {\n                throw new Error(name + \" state is not defined\");\n            }\n            this._current = states[name];\n        };\n        /**\n         * Creates or gets existing State\n         *\n         * @param Name - state name\n         * @return State specified by name\n         */\n        StateMachine.prototype.state = function (name) {\n            var states = this._states;\n            if (!states.hasOwnProperty(name)) {\n                states[name] = new State(this, name);\n            }\n            return states[name];\n        };\n        /**\n         * Gets the name of the current State\n         *\n         * @return name Current state name\n         */\n        StateMachine.prototype.current = function () {\n            var current = this._current;\n            if (current === null) {\n                throw new Error(\"the state machine has not been initialized\");\n            }\n            return current._name;\n        };\n        /**\n         * Emit an event\n         *\n         * @param event Event name\n         * @param args Arguments to pass to event handler\n         */\n        StateMachine.prototype.emit = function (event) {\n            var _this = this;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var verbose = this._options.verbose, name = this._options.name, logEx = this._options.logExceptions, state = this._current, events;\n            if (state === null) {\n                throw new Error(\"the state machine has not been initialized\");\n            }\n            events = state._events;\n            if (!events.hasOwnProperty(event)) {\n                throw new Error(event + \" event not defined for \" + state._name + \" state\");\n            }\n            if (verbose) {\n                console.log(name + \": \" + state._name + \".\" + event);\n            }\n            if (logEx) {\n                try {\n                    events[event].forEach(function (fn) { return fn.apply(_this, args); });\n                }\n                catch (e) {\n                    console.log(name + \": \" + state._name + \" ! \" + e.message);\n                    throw e;\n                }\n            }\n            else {\n                events[event].forEach(function (fn) { return fn.apply(_this, args); });\n            }\n        };\n        /**\n         * Go to another state\n         *\n         * @param name State to transition to\n         */\n        StateMachine.prototype.go = function (name) {\n            var _this = this;\n            var state = this._states[name], current = this._current, execute = function (fn) { return fn.call(_this); };\n            if (isUndefined(state)) {\n                throw new Error(name + \" state does not exist\");\n            }\n            if (current._name !== name) {\n                if (this._options.verbose) {\n                    console.log(this._options.name + \": \" + current._name + \" -> \" + name);\n                }\n                current._exit.forEach(execute);\n                this._current = state;\n                state._enter.forEach(execute);\n            }\n        };\n        return StateMachine;\n    })();\n    _StateMachine.StateMachine = StateMachine;\n})(StateMachine || (StateMachine = {}));\n"],"sourceRoot":"/source/"}